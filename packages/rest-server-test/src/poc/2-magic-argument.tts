export type Diff<T, U> = T extends U ? never : T;

type CalculateMissing<Set, SubSet>
    = Diff<Set, SubSet> extends never
    ? [undefined?]
    : [Diff<Set, SubSet>]
;


export function createServer<AllRoutes extends string>() {

    function registerAllRoutes<ProvidedRoutes extends string>(routes: ProvidedRoutes[], ...missing: CalculateMissing<AllRoutes, ProvidedRoutes>) {

    }
    return {
        registerAllRoutes
    }
}

// Pass the Type parameter in here
const {registerAllRoutes} = createServer<'A' | 'B' | 'C'>();

// Use type inference here
registerAllRoutes(['A', 'B', 'C']); // Ok
registerAllRoutes(['A', 'C', 'B']); // Ok
registerAllRoutes(['A', 'B', 'C', 'X']); // Ok (but ideally not)
registerAllRoutes(['A', 'B', 'C', 'C']); // Ok (but ideally not)
registerAllRoutes(['A', 'B'],); // Error, missing C